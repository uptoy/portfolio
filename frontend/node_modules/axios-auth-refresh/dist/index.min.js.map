{"version":3,"file":"index.min.js","mappings":"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","sources":["webpack://axios-auth-refresh/webpack/universalModuleDefinition","webpack://axios-auth-refresh/./src/utils.ts","webpack://axios-auth-refresh/external umd \"axios\"","webpack://axios-auth-refresh/webpack/bootstrap","webpack://axios-auth-refresh/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"axios\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"axios\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"axios-auth-refresh\"] = factory(require(\"axios\"));\n\telse\n\t\troot[\"axios-auth-refresh\"] = factory(root[\"axios\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__300__) {\nreturn ","import axios, { AxiosInstance, AxiosPromise, AxiosRequestConfig } from 'axios';\nimport { AxiosAuthRefreshOptions, AxiosAuthRefreshCache } from './model';\n\nexport interface CustomAxiosRequestConfig extends AxiosRequestConfig {\n    skipAuthRefresh?: boolean\n}\n\nexport const defaultOptions: AxiosAuthRefreshOptions = {\n  statusCodes: [ 401 ],\n  pauseInstanceWhileRefreshing: false,\n};\n\n/**\n * Merges two options objects (options overwrites defaults).\n *\n * @return {AxiosAuthRefreshOptions}\n */\nexport function mergeOptions(\n  defaults: AxiosAuthRefreshOptions,\n    options: AxiosAuthRefreshOptions,\n): AxiosAuthRefreshOptions {\n  return {\n    ...defaults,\n    pauseInstanceWhileRefreshing: options.skipWhileRefreshing,\n    ...options,\n  };\n}\n\n/**\n * Returns TRUE: when error.response.status is contained in options.statusCodes\n * Returns FALSE: when error or error.response doesn't exist or options.statusCodes doesn't include response status\n *\n * @return {boolean}\n */\nexport function shouldInterceptError(\n    error: any,\n    options: AxiosAuthRefreshOptions,\n    instance: AxiosInstance,\n    cache: AxiosAuthRefreshCache,\n): boolean {\n  if (!error) {\n    return false;\n  }\n\n  if (error.config?.skipAuthRefresh) {\n    return false;\n  }\n\n  if (\n    !(options.interceptNetworkError && !error.response && error.request.status === 0) &&\n    (!error.response || !options.statusCodes?.includes(parseInt(error.response.status)))\n  ) {\n    return false;\n  }\n\n  // Copy config to response if there's a network error, so config can be modified and used in the retry\n  if (!error.response) {\n    error.response = {\n      config: error.config,\n    };\n  }\n\n  return !options.pauseInstanceWhileRefreshing || !cache.skipInstances.includes(instance);\n}\n\n/**\n * Creates refresh call if it does not exist or returns the existing one.\n *\n * @return {Promise<any>}\n */\nexport function createRefreshCall(\n    error: any,\n    fn: (error: any) => Promise<any>,\n    cache: AxiosAuthRefreshCache,\n): Promise<any> {\n  if (!cache.refreshCall) {\n    cache.refreshCall = fn(error);\n    if (typeof cache.refreshCall.then !== 'function') {\n      console.warn('axios-auth-refresh requires `refreshTokenCall` to return a promise.');\n      return Promise.reject();\n    }\n  }\n  return cache.refreshCall;\n}\n\n/**\n * Creates request queue interceptor if it does not exist and returns its id.\n *\n * @return {number}\n */\nexport function createRequestQueueInterceptor(\n    instance: AxiosInstance,\n    cache: AxiosAuthRefreshCache,\n    options: AxiosAuthRefreshOptions,\n): number {\n  if (typeof cache.requestQueueInterceptorId === 'undefined') {\n    cache.requestQueueInterceptorId = instance.interceptors.request.use((request: CustomAxiosRequestConfig) => {\n      if(request?.skipAuthRefresh)\n        return request\n      return cache.refreshCall\n          .catch(() => {\n            throw new axios.Cancel('Request call failed');\n          })\n          .then(() => options.onRetry ? options.onRetry(request) : request);\n    });\n  }\n  return cache.requestQueueInterceptorId;\n}\n\n/**\n * Ejects request queue interceptor and unset interceptor cached values.\n *\n * @param {AxiosInstance} instance\n * @param {AxiosAuthRefreshCache} cache\n */\nexport function unsetCache(\n    instance: AxiosInstance,\n    cache: AxiosAuthRefreshCache,\n): void {\n  instance.interceptors.request.eject(cache.requestQueueInterceptorId);\n  cache.requestQueueInterceptorId = undefined;\n  cache.refreshCall = undefined;\n  cache.skipInstances = cache.skipInstances.filter(skipInstance => skipInstance !== instance);\n}\n\n/**\n * Returns instance that's going to be used when requests are retried\n *\n * @param instance\n * @param options\n */\nexport function getRetryInstance(instance: AxiosInstance, options: AxiosAuthRefreshOptions): AxiosInstance {\n  return options.retryInstance || instance;\n}\n\n/**\n * Resend failed axios request.\n *\n * @param {any} error\n * @param {AxiosInstance} instance\n * @return AxiosPromise\n */\nexport function resendFailedRequest(\n    error: any,\n    instance: AxiosInstance\n): AxiosPromise {\n  error.config.skipAuthRefresh = true;\n  return instance(error.response.config);\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__300__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { AxiosInstance, AxiosResponse, AxiosPromise } from 'axios';\nimport { AxiosAuthRefreshOptions, AxiosAuthRefreshCache } from './model';\nimport {\n    unsetCache,\n    mergeOptions,\n    defaultOptions,\n    getRetryInstance,\n    createRefreshCall,\n    resendFailedRequest,\n    shouldInterceptError,\n    createRequestQueueInterceptor,\n} from './utils';\n\nexport { AxiosAuthRefreshOptions, AxiosAuthRefreshRequestConfig } from './model';\n\n/**\n * Creates an authentication refresh interceptor that binds to any error response.\n * If the response status code is one of the options.statusCodes, interceptor calls the refreshAuthCall\n * which must return a Promise. While refreshAuthCall is running, all the new requests are intercepted and are waiting\n * for the refresh call to resolve. While running the refreshing call, instance provided is marked as a paused instance\n * which indicates the interceptor to not intercept any responses from it. This is because you'd otherwise need to mark\n * the specific requests you make by yourself in order to make sure it's not intercepted. This behavior can be\n * turned off, but use it with caution as you need to mark the requests with `skipAuthRefresh` flag yourself in order to\n * not run into interceptors loop.\n *\n * @param {AxiosInstance} instance - Axios HTTP client instance\n * @param {(error: any) => Promise<AxiosPromise>} refreshAuthCall - refresh token call which must return a Promise\n * @param {AxiosAuthRefreshOptions} options - options for the interceptor @see defaultOptions\n * @return {number} - interceptor id (in case you want to eject it manually)\n */\nexport default function createAuthRefreshInterceptor(\n    instance: AxiosInstance,\n    refreshAuthCall: (error: any) => Promise<any>,\n    options: AxiosAuthRefreshOptions = {},\n): number {\n\n    if (typeof refreshAuthCall !== 'function') {\n        throw new Error('axios-auth-refresh requires `refreshAuthCall` to be a function that returns a promise.');\n    }\n\n    const cache: AxiosAuthRefreshCache = {\n        skipInstances: [],\n        refreshCall: undefined,\n        requestQueueInterceptorId: undefined,\n    };\n\n    return instance.interceptors.response.use((response: AxiosResponse) => response, (error: any) => {\n\n        options = mergeOptions(defaultOptions, options);\n\n        if (!shouldInterceptError(error, options, instance, cache)) {\n            return Promise.reject(error);\n        }\n\n        if (options.pauseInstanceWhileRefreshing) {\n            cache.skipInstances.push(instance);\n        }\n\n        // If refresh call does not exist, create one\n        const refreshing = createRefreshCall(error, refreshAuthCall, cache);\n\n        // Create interceptor that will bind all the others requests until refreshAuthCall is resolved\n        createRequestQueueInterceptor(instance, cache, options);\n\n        return refreshing\n            .finally(() => unsetCache(instance, cache))\n            .catch(error => Promise.reject(error))\n            .then(() => resendFailedRequest(error, getRetryInstance(instance, options)));\n    });\n}\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__300__","defaultOptions","statusCodes","pauseInstanceWhileRefreshing","defaults","options","skipWhileRefreshing","error","instance","cache","config","skipAuthRefresh","interceptNetworkError","response","request","status","includes","parseInt","skipInstances","fn","refreshCall","then","console","warn","Promise","reject","requestQueueInterceptorId","interceptors","use","catch","Cancel","onRetry","eject","undefined","filter","skipInstance","retryInstance","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","refreshAuthCall","Error","mergeOptions","shouldInterceptError","push","refreshing","createRefreshCall","createRequestQueueInterceptor","finally","unsetCache","resendFailedRequest","getRetryInstance"],"sourceRoot":""}